sd_params
d_params = c()
sd_params = c()
sxd_params = c()
model_fits = list()
for (i in 1:length(phylo_trees)){
### pick a phylogenetic tree
one_tree = phylo_trees[[i]]
### set models
sxd = make.geosse(one_tree, states=geo_states, sampling.f=0.9)
sd = constrain(sxd, xA ~ xB)
d = constrain(sxd, sA ~ sB, xA ~ xB)
### starting values
start_geosse = starting.point.geosse(one_tree)
### find mle
# all constant
mle_d = find.mle(d, start_geosse)
d_params = rbind(d_params, mle_d$par)
# varying lambda
mle_sd = find.mle(sd, start_geosse)
sd_params = rbind(sd_params, mle_sd$par)
# varying lambda and mu
mle_sxd = find.mle(sxd, start_geosse)
sxd_params = rbind(sxd_params, mle_sxd$par)
### summarizing model fit
d_fit = c(lnlik= mle_d$lnLik, n_par=length(mle_d$par))
sd_fit = c(mle_sd$lnLik, length(mle_sd$par))
sxd_fit = c(mle_sxd$lnLik, length(mle_sxd$par))
fit_values = rbind(d_fit, sd_fit, sxd_fit)
model_fits[[i]] = fit_values
}
d_params = c()
sd_params = c()
sxd_params = c()
model_fits = list()
for (i in 1:length(phylo_trees)){
### pick a phylogenetic tree
one_tree = phylo_trees[[i]]
### set models
sxd = make.geosse(one_tree, states=geo_states, sampling.f=0.9)
sd = constrain(sxd, xA ~ xB)
d = constrain(sxd, sA ~ sB, xA ~ xB)
### starting values
start_geosse = starting.point.geosse(one_tree)
### find mle
# all constant
mle_d = find.mle(d, start_geosse)
d_params = rbind(d_params, mle_d$par)
# varying lambda
mle_sd = find.mle(sd, start_geosse)
sd_params = rbind(sd_params, mle_sd$par)
# varying lambda and mu
mle_sxd = find.mle(sxd, start_geosse)
sxd_params = rbind(sxd_params, mle_sxd$par)
### summarizing model fit
d_fit = c(lnlik= mle_d$lnLik, n_par=length(mle_d$par))
sd_fit = c(mle_sd$lnLik, length(mle_sd$par))
sxd_fit = c(mle_sxd$lnLik, length(mle_sxd$par))
fit_values = rbind(d_fit, sd_fit, sxd_fit)
model_fits[[i]] = fit_values
print(paste("Time:", Sys.time(), "Loop iterarion:", as.character(i) ) )
}
### arranging into dara frame
model_fits_df = data.frame()
for (i in 1:length(model_fits)){
model_fits_df = rbind(model_fits_df, model_fits[[i]])
}
model_fits_df
### AIC = -2(log-likelihood) + 2K
aic = -2*model_fits_df$lnlik +2*(model_fits_df$n_par)
### AiC = AIC - 2k(k+1) / (n-k-1)
aicc = aic -2*(model_fits_df$n_par+1)/(66-model_fits_df$n_par-1)
### adding
model_fits_df = data.frame(model_fits_df, aic, aicc)
model_fits_df
### exporting
write.table(model_fits_df, "geosse/geosse_model_fits_df.csv", sep=",", quote=F, row.names = T)
write.table(const_params, "geosse/d_params.csv", sep=",", quote=F, row.names = F)
write.table(linear_params, "geosse/sd_params.csv", sep=",", quote=F, row.names = F)
write.table(sigm_params, "geosse/sxd_params.csv", sep=",", quote=F, row.names = F)
model_fits_df= read.table("geosse/geosse_model_fits_df.csv", sep=",", h = T)
model_fits_df
length(phylo_trees)*3
seq(1, by =2)
seq(1, 297, by =2)
seq(1, 297, by =3)
seq(1, 298, by =3)
seq(1, 292, by =3)
seq(1, 295, by =3)
seq(1, 298, by =3)
best_fit_per_tree =c()
by_three = seq(1, 298, by =3)
for (i in by_three){
one_set = model_fits_df[i:(i+2),]
best_fit_per_tree = rbind(best_fit_per_tree, one_set[one_set$aicc==min(one_set$aicc),] )
}
best_fit_per_tree
model_fits_df
by_three
first_lowest_aicc[one_set$aicc==min(one_set$aicc),]
first_lowest = one_set[one_set$aicc==min(one_set$aicc),]
first_lowest
which(one_set$aicc==min(one_set$aicc) )
minus_first = one_set[-which(one_set$aicc==min(one_set$aicc) ),]
minus_first[minus_first$aicc==min(minus_first$aicc),]
second_lowest = minus_first[minus_first$aicc==min(minus_first$aicc),]
second_lowest$aicc - first_lowest$aicc
second_lowest$aicc - first_lowest$aicc < 2
second_lowest
best_fit_per_tree =c()
index = seq(1, 298, by =3)
for (i in index){
one_set = model_fits_df[i:(i+2),]
first_lowest = one_set[one_set$aicc==min(one_set$aicc),]
minus_first = one_set[-which(one_set$aicc==min(one_set$aicc) ),]
second_lowest = minus_first[minus_first$aicc==min(minus_first$aicc),]
if (second_lowest$aicc - first_lowest$aicc < 2){
best_fit_per_tree = rbind(best_fit_per_tree, second_lowest)
} else {
best_fit_per_tree = rbind(best_fit_per_tree, first_lowest)
}
}
best_fit_per_tree
names(best_fit_per_tree)
rownames(best_fit_per_tree)
strsplit(rownames(best_fit_per_tree), sep='_')
strsplit(rownames(best_fit_per_tree), '_')
str_names = strsplit(rownames(best_fit_per_tree), '_')
str_names[[1]]
str_names[[1]][1]
1:nrow(best_fit_per_tree)
model_name = c()
for(i in 1:nrow(best_fit_per_tree)){
str_names = strsplit(rownames(best_fit_per_tree), '_')
model_name = c(model_name, str_names[[i]][1])
}
model_name
best_fit_per_tree
best_fit_per_tree[,1:4]
as.matrix(best_fit_per_tree[,1:4])
as.numeric(best_fit_per_tree[,1:4])
data.frame(model_name, best_fit_per_tree[,1:4])
### exporting
write.table(model_fits_df, "geosse/best_fit_models.csv", sep=",", quote=F, row.names = F)
table(best_fit_models)
table(best_fit_models$model_name)
best_fit_models
best_fit_models = data.frame(model_name, best_fit_per_tree)
### exporting
write.table(best_fit_models, "geosse/best_fit_models.csv", sep=",", quote=F, row.names = F)
table(best_fit_models$model_name)
### setting linear function
xr = c(0,30)
linear.x = make.linear.x(x0=xr[1], x1=xr[2])
### pick a phylogenetic tree
i = 2
one_tree = phylo_trees[[i]]
### starting parameter values
start_values = starting.point.quasse(one_tree, states=trait_values)
const = constrain(const, drift ~ 0)
### setting quasse functions
# constant
const =  make.quasse(one_tree, states=trait_values, states.sd=se_trait , lambda=constant.x, mu=constant.x, sampling.f=0.9)
const = constrain(const, drift ~ 0)
# linear
linear = make.quasse(one_tree,  states=trait_values, states.sd=se_trait , lambda=linear.x, mu=linear.x, sampling.f=0.9)
linear = constrain(linear, drift ~ 0)
argnames(const)
#sigm = constrain(sigm, drift ~ 0)
### optimization
## constant
# initial values
init_const = c(start_values[1], start_values[2], start_values[3])
lower_const = c(0,0,0)
names(lower_const) = names(init_const) = argnames(const)
# finding constant mle
mle_const = find.mle(const, x.init=init_const, lower=lower_const, control=control)
argnames(linear)
mle_const$par
## linear
# initial values
init_linear = c(mle_const$par[1], 0.1*mle_const$par[1], mle_const$par[2], 10*mle_const$par[2], mle_const$par[3])
names(init_linear) = argnames(linear)
init_linear
# finding linear mle
mle_linear = find.mle(linear, x.init=init_linear, control=control)
mle_const
mle_linear
anov(mle_const, mle_linear)
aov(mle_const, mle_linear)
anova(mle_const, mle_linear)
init_linear
mle_const$par
mle_linear$par
plot(trait_value, (mle_linear[2]*trait_value)+mle_linear[1])
trait_values
plot(trait_values, (mle_linear[2]*trait_values)+mle_linear[1])
plot(trait_values, (mle_linear[2]*trait_values)+mle_linear[1])
mle_linear[2]*trait_values
plot(trait_values, (mle_linear$par[2]*trait_values)+mle_linear$par[1])
mle_linear$par
plot(trait_values, (mle_linear$par[3]*trait_values)+mle_linear$par[4])
sd$par
mle_sd$par
### starting parameter values
start_quasse = starting.point.quasse(one_tree, states=trait_values)
start_quasse
### setting quasse functions
# constant
const =  make.quasse(one_tree, states=trait_values, states.sd=se_trait , lambda=constant.x, mu=constant.x, sampling.f=0.9)
const = constrain(const, drift ~ 0)
### starting parameter values
start_quasse = starting.point.quasse(one_tree, states=trait_values)
### setting quasse functions
# constant
const =  make.quasse(one_tree, states=trait_values, states.sd=se_trait , lambda=constant.x, mu=constant.x, sampling.f=0.9)
#const = constrain(const, drift ~ 0)
# linear lambda
l_lin = make.quasse(one_tree,  states=trait_values, states.sd=se_trait , lambda=linear.x, mu=constant.x, sampling.f=0.9)
#l_lin = constrain(linear, drift ~ 0)
# linear lambda and mu
lm_lin = make.quasse(one_tree, states=trait_values, states.sd=se_trait , lambda=linear.x, mu=linear.x, sampling.f=0.9)
#lm_lin = constrain(lm_lin, drift ~ 0)
### optimization
## constant
# initial values
init_const = c(start_quasse[1], start_quasse[2], start_quasse[3])
lower_const = c(0,0,0)
names(lower_const) = names(init_const) = argnames(const)
argnames(const)
#lm_lin = constrain(lm_lin, drift ~ 0)
### optimization
## constant
# initial values
init_const = c(start_quasse[1], start_quasse[2], 0.01, start_quasse[3])
lower_const = c(0,0,0,0)
names(lower_const) = names(init_const) = argnames(const)
# finding constant mle
mle_const = find.mle(const, x.init=init_const, lower=lower_const, control=control)
mle_const$par
argnames(l_lin)
mle_const$par[2]
mle_const$par[3:4]
## linear
# initial values
init_l_lin = c(mle_const$par[1], *mle_const$par[1], mle_const$par[2], mle_const$par[3:4])
## linear
# initial values
init_l_lin = c(mle_const$par[1], mle_const$par[1], mle_const$par[2], mle_const$par[3:4])
names(init_l_lin) = argnames(l_lin)
init_l_lin
## linear
# initial values
init_l_lin = c(mle_const$par[1], 0.01, mle_const$par[2], mle_const$par[3:4])
names(init_l_lin) = argnames(l_lin)
init_l_lin
# finding mle linear lambda
mle_l_lin = find.mle(l_lin, x.init=init_l_lin, control=control)
mle_linear$par
l_lin_params = rbind(l_lin_params, mle_l_lin$par)
mle_l_lin$par
mle_sd$par
max(trait_value)
max(trait_values)
start_quasse["diffusion"]
c(0,max(trait_values)+ 20*start_quasse["diffusion"])
### starting parameter values and linear function
start_quasse = starting.point.quasse(one_tree, states=trait_values)
start_quasse
c(-20,20)*start_quasse["diffusion"]
c(range(trait_values) + c(-20,20)*start_quasse["diffusion"])
xr = c(range(trait_values) + c(-20,20)*start_quasse["diffusion"])
linear.x = make.linear.x(x0=xr[1], x1=xr[2])
linear.x
str(linear.x)
make.linear.x
linear.x = make.linear.x(x0=xr[1], x1=xr[2])
### setting quasse functions
# constant
const =  make.quasse(one_tree, states=trait_values, states.sd=se_trait , lambda=constant.x, mu=constant.x, sampling.f=0.9)
#const = constrain(const, drift ~ 0)
# linear lambda
l_lin = make.quasse(one_tree,  states=trait_values, states.sd=se_trait , lambda=linear.x, mu=constant.x, sampling.f=0.9)
init_l_lin
argnames(lm_lin)
mle_const$par[2]
mle_const$par[3:4]
## linear lambda and mu
init_lm_lin = c(mle_const$par[1], 0.01, mle_const$par[2], 0.01*mle_const$par[2], mle_const$par[3:4])
names(init_lm_lin) = argnames(lm_lin)
# finding mle linearlambda and mu
mle_lm_lin = find.mle(lm_lin, x.init=init_lm_lin, control=control)
mle_lm_lin$par
c(range(trait_values) + c(-1,1)*start_quasse["diffusion"])
### setting quasse functions
# constant
const =  contrains(make.quasse(one_tree, states=trait_values, states.sd=se_trait , lambda=constant.x, mu=constant.x, sampling.f=0.9), drift~0)
### setting quasse functions
# constant
const =  contrain(make.quasse(one_tree, states=trait_values, states.sd=se_trait , lambda=constant.x, mu=constant.x, sampling.f=0.9), drift~0)
### setting quasse functions
# constant
const =  constrain(make.quasse(one_tree, states=trait_values, states.sd=se_trait , lambda=constant.x, mu=constant.x, sampling.f=0.9), drift~0)
i = 2
one_tree = phylo_trees[[i]]
### starting parameter values and linear function
start_quasse = starting.point.quasse(one_tree, states=trait_values)
xr = c(range(trait_values) + c(-1,1)*start_quasse["diffusion"])
linear.x = make.linear.x(x0=xr[1], x1=xr[2])
### setting quasse functions
# constant
const =  constrain(make.quasse(one_tree, states=trait_values, states.sd=se_trait , lambda=constant.x, mu=constant.x, sampling.f=0.9), drift~0)
# linear lambda
l_lin = constrain(make.quasse(one_tree,  states=trait_values, states.sd=se_trait , lambda=linear.x, mu=constant.x, sampling.f=0.9), drift~0)
# linear lambda and mu
lm_lin = constrain(make.quasse(one_tree, states=trait_values, states.sd=se_trait , lambda=linear.x, mu=linear.x, sampling.f=0.9), drift~0)
### optimization
## constant
# initial values
init_const = c(start_quasse[1], start_quasse[2], 0.01, start_quasse[3])
lower_const = c(0,0,0,0)
names(lower_const) = names(init_const) = argnames(const)
# finding constant mle
mle_const = find.mle(const, x.init=init_const, lower=lower_const, control=control)
const_params = rbind(const_params, mle_const$par)
## linear lambda
# initial values
init_l_lin = c(mle_const$par[1], 0.01, mle_const$par[2], mle_const$par[3:4])
names(init_l_lin) = argnames(l_lin)
# finding mle =
mle_l_lin = find.mle(l_lin, x.init=init_l_lin, control=control)
l_lin_params = rbind(l_lin_params, mle_l_lin$par)
## linear lambda and mu
init_lm_lin = c(mle_const$par[1], 0.01, mle_const$par[2], 0.01*mle_const$par[2], mle_const$par[3:4])
names(init_lm_lin) = argnames(lm_lin)
# finding mle linearlambda and mu
mle_lm_lin = find.mle(lm_lin, x.init=init_lm_lin, control=control)
lm_lin_params= rbind(lm_lin_params, mle_lm_lin$par)
### summarizing model fit
const_fit = c(lnlik= mle_const$lnLik, n_par=length(mle_const$par))
l_lin_fit = c(mle_l_lin$lnLik, length(mle_l_lin$par))
lm_lin_fit = c(mle_lm_lin$lnLik, length(mle_lm_lin$par))
fit_values = rbind(const_fit, l_lin_fit, lm_lin_fit)
model_fits[[i]] = fit_values
argnames(lm_lin)
mle_const$par[3:4]
mle_const$par["difussion"]
argnames(l_lin)
start_quasse
i = 2
one_tree = phylo_trees[[i]]
### starting parameter values and linear function
start_quasse = starting.point.quasse(one_tree, states=trait_values)
xr = c(range(trait_values) + c(-1,1)*start_quasse["diffusion"])
linear.x = make.linear.x(x0=xr[1], x1=xr[2])
### setting quasse functions
# constant
const =  constrain(make.quasse(one_tree, states=trait_values, states.sd=se_trait , lambda=constant.x, mu=constant.x, sampling.f=0.9), drift~0)
# linear lambda
l_lin = constrain(make.quasse(one_tree,  states=trait_values, states.sd=se_trait , lambda=linear.x, mu=constant.x, sampling.f=0.9), drift~0)
# linear lambda and mu
lm_lin = constrain(make.quasse(one_tree, states=trait_values, states.sd=se_trait , lambda=linear.x, mu=linear.x, sampling.f=0.9), drift~0)
### optimization
## constant
# initial values
init_const = c(start_quasse[1], start_quasse[2], start_quasse[3])
lower_const = c(0,0,0)
names(lower_const) = names(init_const) = argnames(const)
# finding constant mle
mle_const = find.mle(const, x.init=init_const, lower=lower_const, control=control)
const_params = rbind(const_params, mle_const$par)
## linear lambda
# initial values
init_l_lin = c(mle_const$par[1], 0.01, mle_const$par[2], mle_const$par["diffussion"])
names(init_l_lin) = argnames(l_lin)
# finding mle =
mle_l_lin = find.mle(l_lin, x.init=init_l_lin, control=control)
l_lin_params = rbind(l_lin_params, mle_l_lin$par)
## linear lambda and mu
init_lm_lin = c(mle_const$par[1], 0.01, mle_const$par[2], 0.01*mle_const$par[2], mle_const$par["difussion"])
names(init_lm_lin) = argnames(lm_lin)
# finding mle linearlambda and mu
mle_lm_lin = find.mle(lm_lin, x.init=init_lm_lin, control=control)
lm_lin_params= rbind(lm_lin_params, mle_lm_lin$par)
### summarizing model fit
const_fit = c(lnlik= mle_const$lnLik, n_par=length(mle_const$par))
l_lin_fit = c(mle_l_lin$lnLik, length(mle_l_lin$par))
lm_lin_fit = c(mle_lm_lin$lnLik, length(mle_lm_lin$par))
fit_values = rbind(const_fit, l_lin_fit, lm_lin_fit)
model_fits[[i]] = fit_values
mle_lm_lin$par
mle_const
mle_const$par
mle_const$par["diffussion"]
mle_const$par
const_params = c()
l_lin_params = c()
lm_lin_params = c()
model_fits = list()
init_l_lin = c(mle_const$par[1], 0.01, mle_const$par[2], mle_const$par[3])
names(init_l_lin) = argnames(l_lin)
# finding mle =
mle_l_lin = find.mle(l_lin, x.init=init_l_lin, control=control)
l_lin_params = rbind(l_lin_params, mle_l_lin$par)
## linear lambda and mu
init_lm_lin = c(mle_const$par[1], 0.01, mle_const$par[2], 0.01*mle_const$par[2], mle_const$par[3])
names(init_lm_lin) = argnames(lm_lin)
# finding mle linearlambda and mu
mle_lm_lin = find.mle(lm_lin, x.init=init_lm_lin, control=control)
lm_lin_params= rbind(lm_lin_params, mle_lm_lin$par)
### summarizing model fit
const_fit = c(lnlik= mle_const$lnLik, n_par=length(mle_const$par))
l_lin_fit = c(mle_l_lin$lnLik, length(mle_l_lin$par))
lm_lin_fit = c(mle_lm_lin$lnLik, length(mle_lm_lin$par))
fit_values = rbind(const_fit, l_lin_fit, lm_lin_fit)
model_fits[[i]] = fit_values
anova(const, l_lin, lm_lin)
anova(mle_const, mle_l_lin, mle_lm_lin)
mle_lm_lin$par
mle_const$par
plot(trait_values, mle_lm_lin$par[1] + mle_lm_lin$par[2]*trait_values)
plot(trait_values, mle_lm_lin$par[3] + mle_lm_lin$par[4]*trait_values)
lm_lin_fit
fit_values
for (i in 1:length(phylo_trees)){
### pick a phylogenetic tree
one_tree = phylo_trees[[i]]
### starting parameter values and linear function
start_quasse = starting.point.quasse(one_tree, states=trait_values)
xr = c(range(trait_values) + c(-1,1)*start_quasse["diffusion"])
linear.x = make.linear.x(x0=xr[1], x1=xr[2])
### setting quasse functions
# constant
const =  constrain(make.quasse(one_tree, states=trait_values, states.sd=se_trait , lambda=constant.x, mu=constant.x, sampling.f=0.9), drift~0)
# linear lambda
l_lin = constrain(make.quasse(one_tree,  states=trait_values, states.sd=se_trait , lambda=linear.x, mu=constant.x, sampling.f=0.9), drift~0)
# linear lambda and mu
lm_lin = constrain(make.quasse(one_tree, states=trait_values, states.sd=se_trait , lambda=linear.x, mu=linear.x, sampling.f=0.9), drift~0)
### optimization
## constant
# initial values
init_const = c(start_quasse[1], start_quasse[2], start_quasse[3])
lower_const = c(0,0,0)
names(lower_const) = names(init_const) = argnames(const)
# finding constant mle
mle_const = find.mle(const, x.init=init_const, lower=lower_const, control=control)
const_params = rbind(const_params, mle_const$par)
## linear lambda
# initial values
init_l_lin = c(mle_const$par[1], 0.01, mle_const$par[2], mle_const$par[3])
names(init_l_lin) = argnames(l_lin)
# finding mle
mle_l_lin = find.mle(l_lin, x.init=init_l_lin, control=control)
l_lin_params = rbind(l_lin_params, mle_l_lin$par)
## linear lambda and mu
#initial values
init_lm_lin = c(mle_const$par[1], 0.01, mle_const$par[2], 0.01*mle_const$par[2], mle_const$par[3])
names(init_lm_lin) = argnames(lm_lin)
# finding mle
mle_lm_lin = find.mle(lm_lin, x.init=init_lm_lin, control=control)
lm_lin_params= rbind(lm_lin_params, mle_lm_lin$par)
### summarizing model fit
const_fit = c(lnlik= mle_const$lnLik, n_par=length(mle_const$par))
l_lin_fit = c(mle_l_lin$lnLik, length(mle_l_lin$par))
lm_lin_fit = c(mle_lm_lin$lnLik, length(mle_lm_lin$par))
fit_values = rbind(const_fit, l_lin_fit, lm_lin_fit)
model_fits[[i]] = fit_values
### update!
print(paste("Time:", Sys.time(), "Loop iterarion:", as.character(i) ) )
}
### arranging into dara frame
model_fits_df = data.frame()
for (i in 1:length(model_fits)){
model_fits_df = rbind(model_fits_df, model_fits[[i]])
}
### AIC = -2(log-likelihood) + 2K
aic = -2*model_fits_df$lnlik +2*(model_fits_df$n_par)
### AiC = AIC - 2k(k+1) / (n-k-1)
aicc = aic -2*(model_fits_df$n_par+1)/(66-model_fits_df$n_par-1)
### adding
model_fits_df = data.frame(model_fits_df, aic, aicc)
### exporting
write.table(model_fits_df, "quasse/quasse_model_fits_df.csv", sep=",", quote=F, row.names = T)
write.table(const_params, "quasse/const_params.csv", sep=",", quote=F, row.names = F)
write.table(l_lm_params, "quasse/l_lin_params.csv", sep=",", quote=F, row.names = F)
write.table(lm_lin_params, "quasse/lm_lin_params.csv", sep=",", quote=F, row.names = F)
write.table(l_lin_params, "quasse/l_lin_params.csv", sep=",", quote=F, row.names = F)
best_fit_per_tree =c()
index = seq(1, 298, by =3)
for (i in index){
one_set = model_fits_df[i:(i+2),]
first_lowest = one_set[one_set$aicc==min(one_set$aicc),]
minus_first = one_set[-which(one_set$aicc==min(one_set$aicc) ),]
second_lowest = minus_first[minus_first$aicc==min(minus_first$aicc),]
if (second_lowest$aicc - first_lowest$aicc < 2){
best_fit_per_tree = rbind(best_fit_per_tree, second_lowest)
} else {
best_fit_per_tree = rbind(best_fit_per_tree, first_lowest)
}
}
model_name = c()
for(i in 1:nrow(best_fit_per_tree)){
str_names = strsplit(rownames(best_fit_per_tree), '_')
model_name = c(model_name, str_names[[i]][1])
}
best_fit_models = data.frame(model_name, best_fit_per_tree)
best_fit_models
### exporting
write.table(best_fit_models, "quasse/quasse_best_fit_models.csv", sep=",", quote=F, row.names = F)
table(best_fit_models$model_name)
### exporting
write.table(best_fit_models, "quasse/quasse_best_fit_models.csv", sep=",", quote=F, row.names = F)
